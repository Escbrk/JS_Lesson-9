Порядок выполнения кода -> :

1. Синхронный код

   Асинхронный код:

2. Микро задачи (Promise, eventListener и тд.)
3. Макро задачи (setTimeout, setInterval и тд.)

Promise - объект какой является результатом асинхронной операции. У Promise есть
три состояния:

    1. Pending: состояние, когда Promise еще  не выполнился, то есть пока еще нет результата асинхронной операции (например, если послали запрос на сервер, а он долго отвечает)

    2. Fullfilled: состояние, когда Promise выполнился успешно (например, если вызвали функцию resolve)

    3. Rejected: состояние, когда Promise выполнился не успешно (то есть с ошибкой, например, если вызвали функцию rejected)

    НЕ СУЩЕСТВУЕТ состояния Settled, но это условное название для обозначания того, что  Promise просто выполнился (или он Fullfilled, или он Rejected)

    Promise принимает функцию executor (new Promise(executor)), которая принимает еще две функции для перевода Promise в состояние Fullfilled(resolve), или в состояние Rejected(reject). Эта функция не есть асинхронной, то есть, она выполнится в синхронной последовательности кода

    Для обработки результата асинхронной операции, используются слудующие методы:

        - then(onResolve) - принимает callback функцию и обрабатывает успешное выполнение Promise. Возвращает Promise

        - catch(onError) - принимает callback функцию, которая принимает уведомление про ошибку, обрабатывает неуспешное выполнение Promise. Возвращает Promise

        - finaly() - принимает callback функцию, которая выполняется независимо от того, успешно ли выполнился Promise или нет. Просто выполняет какое-то действие по готовности Promise

// !===========================

fetch(URL, [options]) - функция которая делает запрос на сервер, принимает
ссылку (ресурс) и объект наастроек (туда можна передавать всякую информацию о
запросе, например: заголовки, тело, тип запроса и тд.) Fetch по умолчанию делает
GET запрос (запрос для получения информации с ресурса). Всегда возвращает
Promise❗❗❗❗❗

// !===========================

-      Create - POST - создает новый ресурс на сервере, не является идемпотентным
-      Read - GET - запрос, который получает данные с ресурса, является идемпотентным
-      Update -
          PUT - запрос, который полностью обновляет данные на сервере, то есть, если на сервере был объект типа {name: "Mango", age: 27}, после PUT запроса с телом {name: "Kiwi"} -> в результате, на сервере будет объект {name: "Kiwi"} -> является идемпотентным
          PATCH - запрос, который частично обновляет данные на сервере, то есть, если на сервере был объект типа {name: "Mango", age: 27}, после PATCH запроса с телом {name: "Kiwi"} -> в результате, на сервере будет объект {name: "Kiwi", age: 27} -> не является идемпотентным
-      Delete - DELETE - Запрос, который полностью удаляет данные (ресурс) на сервере, [{1}, {2}, {3}] -> DELETE 2 -> [{1}, {3}], является идемпотентным

Идемпотентный метод - это метод, который не будет изменять состояние сервера при
одинаковых повторных запросах:

DB: [{1}, {2}, {3}]

GET:

// !===========================

GET 2 -> response {2} | [{1}, {2}, {3}] GET 2 -> response {2} | [{1}, {2}, {3}]

GET 2 -> response {2} | [{1}, {2}, {3}] GET 2 -> response {2} | [{1}, {2}, {3}]

// !===========================

DELETE:

DELETE 2 -> response 200 {2} | DB: [{1}, {3}]

DELETE 2 -> response 404 | DB: [{1}, {3}]

DELETE 2 -> response 404 | DB: [{1}, {3}]

DELETE 2 -> response 404 | DB: [{1}, {3}]

// !===========================

Идемпотентный метод:

DB: [{1}, {2}, {3}]

POST {4} -> response 201 | DB: [{1}, {2}, {3}, {4}]

POST {4} -> response 201 | DB: [{1}, {2}, {3}, {4}, {4}]

POST {4} -> response 201 | DB: [{1}, {2}, {3}, {4}, {4}, {4}]

POST {4} -> response 201 | DB: [{1}, {2}, {3}, {4}, {4}, {4}, {4}]
